<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>ğŸ’ª 4005 R ile BÃ¼yÃ¼k Veri AnalitiÄŸi</title>
    <meta charset="utf-8" />
    <meta name="author" content="    ğŸ‘©â€ğŸ« Dr.Â KÃ¼bra ATALAY KABASAKAL   Hacettepe Ãœniversitesi" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/font-awesome/css/all.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/v4-shims.css" rel="stylesheet" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="slides-style.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# ğŸ’ª 4005 R ile BÃ¼yÃ¼k Veri AnalitiÄŸi
## <br> ğŸ“Š Veri Manipulasyonu_05
### <br> <br> ğŸ‘©â€ğŸ« Dr.Â KÃ¼bra ATALAY KABASAKAL <br> Hacettepe Ãœniversitesi
### 20/12/2021 <br> <br> <br> <br>ğŸ“§ <a href="mailto:katalay@hacettepe.edu.tr" class="email">katalay@hacettepe.edu.tr</a>

---





layout: true
  
&lt;div class="my-footer"&gt;
&lt;span&gt;
 - Dr. KÃ¼bra Atalay Kabasakal
&lt;/span&gt;
&lt;/div&gt; 

---






# Veri FormatÄ± DegiÅŸtirme .huge[ğŸ“Š]

.hand[Ä°Ã§erik...]
- **tiydr** paketi
- **gather()** fonksiyonu
- **separete()** fonksiyonu
- **spread()** fonksiyonu
- **unite()** fonksiyonu 


---
## Veriyi Ä°nceleme

- Bir veriyi R ortamamÄ±na aktardÄ±ktan sonra

  - Veri setinizde yer alan tÃ¼m satÄ±rlar/sÃ¼tunlar doÄŸru bir ÅŸekilde aktarÄ±lmÄ±ÅŸ mÄ±?
  
  - SÃ¼tun isimleri dÃ¼zgÃ¼n mÃ¼? 
  
  - Ã–zellikle sÃ¼tun adlarÄ±nda boÅŸluk olmasÄ± ya da farklÄ±      karakterler bulunmasÄ± sÄ±kÄ±ntÄ± yaratabilir.

---
## Veriyi Ä°nceleme

- AktarÄ±lan boÅŸ satÄ±r ve sÃ¼tunlar var mÄ±?

  - **filter()** ve **select()** gibi fonksiyonlarla            incelebilir. 
   
- Eksik veriler nasÄ±l temsil ediliyor?

  - **NA**,**" "** (bosluk), **.**, **999** ,  **9999**
  
  - eksik veriler **mutate()** ve **ifelse()** ile             dÃ¼zenlebilir.
  
- character ve factor deÄŸiÅŸkenler dÃ¼zgÃ¼n tanÄ±mlanÄ±mÄ±ÅŸ mÄ±?
  
---
.center[## DaÄŸÄ±nÄ±k Veri]

.pull-left-narrow[
  
    
| **Program**     | **KadÄ±n** | **Erkek**|
|-----------------|----------:|---------:|
| Olcme           |      6    |    6     |
| Program         |      5    |    5     |
| Yonetim         |      7    |    8     |
| PDR             |      5    |    3     |

]
.pull-right-wide[
- GÃ¶zlem nedir?
  - Her bir programda yer alan Ã¶ÄŸrencilerin cinsiyeti
- DeÄŸiÅŸkenler nelerdir?
  - Program, Cinsiyet, Frekans
- DeÄŸerler nelerdir?
    + Program: Olcme, Program, Yonetim, PDR
    + Cinsiyet: KadÄ±n, Erkek 
- BunlarÄ±n degisken deÄŸeri olmasÄ± gerekiyor, sutun baslÄ±ÄŸÄ± deÄŸil!
    + Frekans: ***Frekanslar iki sÃ¼tuna daÄŸÄ±lmÄ±ÅŸ !!!**
]
---
## DÃ¼zgÃ¼n Veri


| **Program**     | **Cinsiyet** | **Frekans** |
|-----------------|-------------:|------------:|
| Olcme           |     KadÄ±n    |    6        |
| Olcme           |     Erkek    |    6        |
| Program         |     KadÄ±n    |    5        |
| Program         |     Erkek    |    5        |
| Yonetim         |     KadÄ±n    |    7        |
| Yonetim         |     Erkek    |    8        |
| PDR             |     KadÄ±n    |    5        |
| PDR             |     Erkek    |    3        |

--
- DeÄŸiÅŸkenler sÃ¼tunda

--

- GÃ¶zlemler SatÄ±rlarda olmalÄ±dÄ±r !
--

---
## DÃ¼zgÃ¼n Veri

- Ã‡ok sayÄ±da **satÄ±rÄ±** anlamlandÄ±rmak, Ã§ok sayÄ±da **sÃ¼tunu** anlamlandÄ±rmaktan daha kolaydÄ±r.

- **ggplot2**,**plotly**,**lattice** gibi paketleri rahat kullanabilmek iÃ§in dÃ¼zenli veri gereklidir.

- hiyerarÅŸik ve karma modeller iÃ§in de verinin dÃ¼zgÃ¼n olmasÄ± Ã¶nemlidir.

- DeÄŸiÅŸken adlarÄ± mÃ¼mkÃ¼n olduÄŸunca anlamlÄ± olmalÄ±dÄ±r.

- Eksik deÄŸerler ve **dengesiz** tekrarlanan Ã¶lÃ§Ã¼m verileriyle ilgili daha az sorun saÄŸlar.

---
## DÃ¼zgÃ¼n Veri

- **tidyr** paketi **reshape** paketi gibi veri dÃ¼zenlemede kullanÄ±labilir.

- **gather()**: bir dizi sÃ¼tun alÄ±r ve onlarÄ± iki yeni sÃ¼tuna (kendi adÄ±nÄ± verebileceÄŸin) dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.

  - A key:  Orijinal sÃ¼tun adlarÄ±nÄ± saklayan bir anahtar
  - A value: Bu orijinal sÃ¼tunlardaki deÄŸerlere sahip bir deÄŸer.
  
---
## **gather()** fonksiyonu

- Fonksiyonun kullanÄ±m ÅŸekli

```r
gather(data, key, value, ..., na.rm = FALSE, 
       convert = FALSE, factor_key = FALSE)
```

- Fonksiyonun kullanÄ±mÄ± gÃ¶stermek iÃ§in veri seti oluÅŸturma


```r
n=20
genisveri &lt;- data.frame(
  ID = paste("ID",101:120,sep=""),
  Sure_1 = sample(50:60,20,replace=TRUE),
  Sure_2 = sample(40:55,20,replace=TRUE),
  Sure_3 = sample(35:50,20,replace=TRUE)
)
```


---
## **gather()** fonksiyonu


```r
genisveri
```

```
##       ID Sure_1 Sure_2 Sure_3
## 1  ID101     59     42     38
## 2  ID102     55     43     42
## 3  ID103     54     54     50
## 4  ID104     58     54     44
## 5  ID105     54     52     45
## 6  ID106     55     49     36
## 7  ID107     53     44     39
## 8  ID108     51     41     49
## 9  ID109     56     53     40
## 10 ID110     55     54     35
## 11 ID111     59     47     40
## 12 ID112     55     50     42
## 13 ID113     53     43     37
## 14 ID114     57     55     40
## 15 ID115     53     51     35
## 16 ID116     53     42     47
## 17 ID117     54     46     50
## 18 ID118     57     48     35
## 19 ID119     53     42     43
## 20 ID120     57     45     42
```

---
## **gather()** 

- gather() fonksiyonu geniÅŸ veriyi, uzun veri haline getirir.


```r
uzun &lt;- genisveri %&gt;% gather(Sure, Zaman, Sure_1:Sure_3)
```

- Olusan veride Sure_1,Sure_2 ve Sure_3, Sure deÄŸiÅŸkenin deÄŸerleri haline geldi.

---
## **gather()** 


```r
uzun %&gt;% head(3)
```

```
##      ID   Sure Zaman
## 1 ID101 Sure_1    59
## 2 ID102 Sure_1    55
## 3 ID103 Sure_1    54
```

```r
uzun %&gt;% tail(3)
```

```
##       ID   Sure Zaman
## 58 ID118 Sure_3    35
## 59 ID119 Sure_3    43
## 60 ID120 Sure_3    42
```


- GÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi, ÅŸimdi iki sÃ¼tunumuz var: Biri *Sure* iÃ§in, diÄŸeri **Zaman** iÃ§in. Her katÄ±lÄ±mcÄ± icin Ã¼c farkli sÃ¼re degeri olduÄŸu iÃ§in her bir ID deÄŸeri Ã¼Ã§ kere tekrarlamaktadÄ±r.

---
## **separate()**

- **separate()** bir sÃ¼tunu birden Ã§ok sÃ¼tuna ayÄ±rÄ±r.

- deÄŸerlerin sÃ¼tun adlarÄ±na gÃ¶mÃ¼ldÃ¼ÄŸÃ¼ toplanmÄ±ÅŸ verilerde ortaktÄ±r.

- Olusan veride Sure_1,Sure_2 ve Sure_3 deÄŸerlerinin karakter ve sayÄ±sal deÄŸerlerini ayÄ±rmak iÃ§in **separate():** fonkisyonu kullanabilirsiniz.



```r
uzun_ayrÄ± &lt;- uzun %&gt;% 
            separate(Sure, c("Sure","SayÄ±"),"_") 

uzun_ayrÄ± %&gt;% head(3)
```

```
##      ID Sure SayÄ± Zaman
## 1 ID101 Sure    1    59
## 2 ID102 Sure    1    55
## 3 ID103 Sure    1    54
```

---
## **unite()** fonksiyonu

- **gather*()** fonksiyonun tam tersi olarak iki sÃ¼tunu alÄ±p
tek sutunda birlestirir.


```r
uzun_birles &lt;- uzun_ayrÄ± %&gt;% unite(SURE, Sure, SayÄ±, sep = ".")
uzun_birles %&gt;% head(3)
```

```
##      ID   SURE Zaman
## 1 ID101 Sure.1    59
## 2 ID102 Sure.1    55
## 3 ID103 Sure.1    54
```

---
## **spread()** fonksiyonu

- **spread():**  **gather*()** fonksiyonun tam tersini yaparak uzun veriden genis veri olusturmaya yarar.


```r
tekrar_genis &lt;- uzun_birles %&gt;% spread(SURE, Zaman)
tekrar_genis
```

```
##       ID Sure.1 Sure.2 Sure.3
## 1  ID101     59     42     38
## 2  ID102     55     43     42
## 3  ID103     54     54     50
## 4  ID104     58     54     44
## 5  ID105     54     52     45
## 6  ID106     55     49     36
## 7  ID107     53     44     39
## 8  ID108     51     41     49
## 9  ID109     56     53     40
## 10 ID110     55     54     35
## 11 ID111     59     47     40
## 12 ID112     55     50     42
## 13 ID113     53     43     37
## 14 ID114     57     55     40
## 15 ID115     53     51     35
## 16 ID116     53     42     47
## 17 ID117     54     46     50
## 18 ID118     57     48     35
## 19 ID119     53     42     43
## 20 ID120     57     45     42
```


---

&lt;br&gt;

.hand-large[teÅŸekkÃ¼rler !]

--


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-light",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
